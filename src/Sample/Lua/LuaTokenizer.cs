using Kelson.Common.Parse;
using Kelson.Common.Parse.Rules;

namespace Lua
{
    public static class LuaTokenizer
    {
        public static TokenList<Tkn> Scan(string text) => Value.Scan(text);

        private static Tokenizer<Tkn> Value = new TokenizerBuilder<Tkn>()
            .Produce(Tkn.WhiteSpace, ' ', '\t', '\r', '\n')            
            .Produce(Tkn.LParen, '(')
            .Produce(Tkn.RParen, ')')
            .Produce(Tkn.Underscore, '_')
            .Produce(Tkn.Add, '+')
            .Produce(Tkn.Sub, '-')
            .Produce(Tkn.Multiply, '*')
            .Produce(Tkn.Division, '/')
            .Produce(Tkn.Equality, "==")
            .Produce(Tkn.Assign, '=')
            .Produce(Tkn.Semi, ';')
            .Produce(Tkn.Comma, ',')
            .Produce(Tkn.Concat, "..")
            .Produce(Tkn.Period, '.')
            .Produce(Tkn.Keyword_Function, "function ")
            .Produce(Tkn.Keyword_Do, "do ")
            .Produce(Tkn.Keyword_While, "while ")
            .Produce(Tkn.Keyword_For, "for ")
            .Produce(Tkn.Keyword_In, "in ")
            .Produce(Tkn.Keyword_End, "end ")
            .Produce(Tkn.Keyword_If, "if ")
            .Produce(Tkn.Keyword_Then, "then ")
            .Produce(Tkn.Keyword_ElseIf, "elseif ")
            .Produce(Tkn.Keyword_Else, "else ")
            .Produce(Tkn.Keyword_Repeat, "repeat ")
            .Produce(Tkn.Keyword_Until, "until ")
            .Produce(Tkn.Keyword_Break, "break ")
            .Produce(Tkn.Keyword_True, "true ")
            .Produce(Tkn.Keyword_False, "false ")
            .Produce(Tkn.Keyword_Nil, "nil ")
            .Produce(Tkn.Keyword_Goto, "goto ")
            .Produce(Tkn.Keyword_And, "and ")
            .Produce(Tkn.Keyword_Or, "or ")
            .Produce(Tkn.Keyword_Not, "not ")
            .Produce(Tkn.Keyword_Return, "return ")
            .Produce(Tkn.Letter, new Predicate<char>(c => (char.IsLetter(c.Peek()), c.Next())))
            .Produce(Tkn.Digit, new Predicate<char>(c => (char.IsDigit(c.Peek()), c.Next())))
            .Build();

        //public static Tokenizer<Tkn> Value = new TokenizerBuilder<Tkn>()            
        //    .Match(Character.WhiteSpace, Tkn.WhiteSpace)
        //    .Match(QuotedString.CStyle, Tkn.Text)            
        //    //.Ignore(Character.WhiteSpace)
        //    .Match(Character.Letter, Tkn.Letter)
        //    .Match(Character.Digit, Tkn.Digit)
        //    .Match(Character.EqualTo('('), Tkn.LParen)
        //    .Match(Character.EqualTo(')'), Tkn.RParen)
        //    .Match(Character.EqualTo('_'), Tkn.Underscore)
        //    .Match(Character.EqualTo('+'), Tkn.Add)
        //    .Match(Character.EqualTo('-'), Tkn.Sub)
        //    .Match(Character.EqualTo('*'), Tkn.Multiply)
        //    .Match(Character.EqualTo('/'), Tkn.Division)
        //    .Match(Span.EqualTo("="), Tkn.Assign)
        //    .Match(Character.EqualTo('?'), Tkn.QuestionMark)
        //    .Match(Character.EqualTo(';'), Tkn.Semi)
        //    .Match(Character.EqualTo(','), Tkn.Comma)
        //    .Match(Span.EqualTo(".."), Tkn.Concat)
        //    .Match(Character.EqualTo('.'), Tkn.Period)
        //    .Match(Span.EqualTo("function"), Tkn.Keyword_Function)
        //    .Match(Span.EqualTo("do"), Tkn.Keyword_Do)
        //    .Match(Span.EqualTo("while"), Tkn.Keyword_While)
        //    .Match(Span.EqualTo("for"), Tkn.Keyword_For)
        //    .Match(Span.EqualTo("in"), Tkn.Keyword_In)
        //    .Match(Span.EqualTo("end"), Tkn.Keyword_End)
        //    .Match(Span.EqualTo("if"), Tkn.Keyword_If)
        //    .Match(Span.EqualTo("elseif"), Tkn.Keyword_ElseIf)
        //    .Match(Span.EqualTo("else"), Tkn.Keyword_Else)
        //    .Match(Span.EqualTo("repeat"), Tkn.Keyword_Repeat)
        //    .Match(Span.EqualTo("until"), Tkn.Keyword_Until)
        //    .Match(Span.EqualTo("break"), Tkn.Keyword_Break)
        //    .Match(Span.EqualTo("true"), Tkn.Keyword_True)
        //    .Match(Span.EqualTo("false"), Tkn.Keyword_False)
        //    .Match(Span.EqualTo("goto"), Tkn.Keyword_Goto)
        //    .Match(Span.EqualTo("local"), Tkn.Keyword_Local)
        //    .Match(Span.EqualTo("nil"), Tkn.Keyword_Nil)
        //    .Match(Span.EqualTo("and"), Tkn.Keyword_And)
        //    .Match(Span.EqualTo("not"), Tkn.Keyword_Not)
        //    .Match(Span.EqualTo("or"), Tkn.Keyword_Or)
        //    .Match(Span.EqualTo("return"), Tkn.Keyword_Return)
        //    .Build();        
    }
}
